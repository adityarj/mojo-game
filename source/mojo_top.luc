module mojo_top (
    input clk,              // 50MHz clock
    input rst_n,            // reset button (active low)
    input cclk,             // configuration clock, AVR ready when high
    input spi_ss,           // AVR SPI Slave Select
    input spi_mosi,         // AVR SPI MOSI
    input spi_sck,          // AVR SPI Clock
    input avr_tx,           // AVR TX (FPGA RX)
    input avr_rx_busy,       // AVR RX buffer full
    input io_dip[4],
    output rand_number[4],
    output output_digit_less[4],
    output output_digit_high[4],
    output operator[9],
    input switch_i,
    input switch_j,
    input enter,
    input reset,
    output io_led[19] //Assign LEDs as 5,4 -> operator LEDs, 3-0 -> RNG LEDs
 
  ) {
 
  sig rst;                  // reset signal
  dff number_sequence[4][4](.clk(clk), .rst(rst));
  dff operator_sequence[2][2](.clk(clk), .rst(rst));
  dff game_over[2](.clk(clk),.rst(rst));
 
  dff current_num[12](.clk(clk), .rst(rst));
  dff i[2](.clk(clk), .rst(rst));
  dff j[2](.clk(clk), .rst(rst));
  dff reset_condition(.clk(clk), .rst(rst));
  dff change_i_condition(.clk(clk), .rst(rst));
  dff change_j_condition(.clk(clk), .rst(rst));
  dff enter_condition(.clk(clk), .rst(rst));
  
  
 
  alu alu;
 
 
  .clk(clk) {
    // The reset conditioner is used to synchronize the reset signal to the FPGA
    // clock. This ensures the entire FPGA comes out of reset at the same time.
    
    reset_conditioner reset_cond; 
    //For debouncing
    button_conditioner reset_button; 
    button_conditioner i_button;
    button_conditioner j_button;
    button_conditioner enter_button;
    
    .rst(rst) {
      pn_gen pn_gen;
      pn_gen pn_gen2;
      pn_gen pn_gen3;
      pn_gen pn_gen4;
      pn_gen pn_gen5;
      pn_gen pn_gen6;
    }
   
  }
 
  always {
 
    output_digit_high = 0;
    output_digit_less = 0;
    
    reset_button.in = reset;
    i_button.in = switch_i;
    j_button.in = switch_j;
    enter_button.in = enter;
   
    io_led[18:0] = 0 ;
    alu.a = 0;
    alu.b = 0;
    alu.alufn = 0;
 
    reset_cond.in = ~rst_n; // input raw inverted reset signal
    rst = reset_cond.out;   // conditioned reset
   
    //Check if reset signal has been asserted, basiscally, at this step, the game is reset
    if (reset_button.out && !reset_condition.q) {
   
   
      io_led[16] = 1;
      //Reset game, set current number to random 0-9, assign new numbers and operators to the user
      current_num.d = pn_gen.num[3:0];
      game_over.d = 0;
     
      reset_condition.d = 1;
     
      //Below are the four inputs that are going to somehow magically generate a number from 0-9
      //We mod these inputs by 10 to make sure they are always from 0-9
      if (pn_gen.num[3:0] < 10) {
        number_sequence.d[0] = pn_gen.num[3:0];
      } else {
        number_sequence.d[0] = pn_gen.num[3:0] - 10;
      }
     
      if (pn_gen2.num[3:0] < 10) {
        number_sequence.d[1] = pn_gen2.num[3:0];
      } else {
        number_sequence.d[1] = pn_gen2.num[3:0] - 10;
      }
     
      if (pn_gen3.num[3:0] < 10) {
        number_sequence.d[2] = pn_gen3.num[3:0];
      } else {
        number_sequence.d[2] = pn_gen3.num[3:0] - 10;
      }
     
      if (pn_gen4.num[3:0] < 10) {
        number_sequence.d[3] = pn_gen4.num[3:0];
      } else {
        number_sequence.d[3] = pn_gen4.num[3:0] - 10;
      }
     
      //Below two numbers magically select a sign
      //%ing them with 4
      if (pn_gen5.num < 4) {
        operator_sequence.d[0] = pn_gen5.num;
      } else {
        operator_sequence.d[0] = pn_gen5.num - (pn_gen5.num/4)*4;
      }
     
      if (pn_gen6.num < 4) {
        operator_sequence.d[1] = pn_gen6.num;
      } else {
        operator_sequence.d[1] = pn_gen6.num - (pn_gen6.num/4)*4;
      }
       
    } else if (!reset_button.out && reset_condition.q) {
   
      io_led[16] = 0;
      reset_condition.d = 0;
     
    }
   
    //Check for change in outputed random numbers
    if (i_button.out && !change_i_condition.q) {
   
       io_led[17] = 1;
   
      if (i.q == 3) {
        i.d = 0;
      } else {
        i.d = i.q + 1;
      }
     
      change_i_condition.d = 1;
     
    } else if (!i_button.out && change_i_condition.q) {
     
      io_led[17] = 0;
      change_i_condition.d = 0;
     
    }
   
    //Check for change in assigned operators
    if (j_button.out && !change_j_condition.q) {
   
      if (j.q == 1) {
        j.d = 0;
      } else {
        j.d = 1;
      }
     
      change_j_condition.d = 1;
     
    } else if (!j_button.out && change_j_condition.q) {
      change_j_condition.d = 0;
    }
   
    //User has hit enter button, calculate the new current number and check accordingly
    if (enter_button.out && !enter_condition.q) {
   
      io_led[18] = 1;
     
      alu.a = current_num.q;
      alu.b = number_sequence.q[i.q];
   
      case(operator_sequence.q[j.q]) {
        2b00: //Performs + operation
          alu.alufn = 6b000000;
        2b01: //Performs - operation
          alu.alufn = 6b000001;
        2b10: //Performs * operation
          alu.alufn = 6b000010;
        2b11: //Performs / operation
          alu.alufn = 6b000011;
        default:
          alu.alufn = 6b000000;
          current_num.d = 0;    
      }
     
      current_num.d = alu.alu_result;
     
     
      //Below are the four inputs that are going to somehow magically generate a number from 0-9
      //We mod these inputs by 10 to make sure they are always from 0-9
      if (pn_gen.num[3:0] < 10) {
        number_sequence.d[0] = pn_gen.num[3:0];
      } else {
        number_sequence.d[0] = pn_gen.num[3:0] - 10;
      }
     
      if (pn_gen2.num[3:0] < 10) {
        number_sequence.d[1] = pn_gen2.num[3:0];
      } else {
        number_sequence.d[1] = pn_gen2.num[3:0] - 10;
      }
     
      if (pn_gen3.num[3:0] < 10) {
        number_sequence.d[2] = pn_gen3.num[3:0];
      } else {
        number_sequence.d[2] = pn_gen3.num[3:0] - 10;
      }
     
      if (pn_gen4.num[3:0] < 10) {
        number_sequence.d[3] = pn_gen4.num[3:0];
      } else {
        number_sequence.d[3] = pn_gen4.num[3:0] - 10;
      }
     
      //Below two numbers magically select a sign
      //%ing them with 4
      if (pn_gen5.num < 4) {
        operator_sequence.d[0] = pn_gen5.num;
      } else {
        operator_sequence.d[0] = pn_gen5.num - (pn_gen5.num/4)*4;
      }
     
      if (pn_gen6.num < 4) {
        operator_sequence.d[1] = pn_gen6.num;
      } else {
        operator_sequence.d[1] = pn_gen6.num - (pn_gen6.num/4)*4;
      }
     
      enter_condition.d = 1;
     
    } else if (!enter_button.out && enter_condition.q) {
   
      io_led[18] = 0;
      enter_condition.d = 0;
     
    }
   
    //Output for number_sequence
    io_led[3:0] = number_sequence.q[i.q];
    rand_number = number_sequence.q[i.q];
    //output for operator_sequence
    io_led[7:6] = operator_sequence.q[j.q];
   
    //Manually hard coding some LED sorcery
    case(operator_sequence.q[j.q]) {
      2b00:
        operator[0] = 0;
        operator[1] = 1;
        operator[2] = 0;
       
        operator[5:3] = 1;
       
        operator[6] = 0;
        operator[7] = 1;
        operator[8] = 0;
       
      2b01:
        operator[2:0] = 0;
       
        operator[5:3] = 1;
       
        operator[8:6] = 0;
       
      2b10:
        operator[0] = 1;
        operator[1] = 0;
        operator[2] = 1;
       
        operator[3] = 0;
        operator[4] = 1;
        operator[5] = 0;
       
        operator[6] = 1;
        operator[7] = 0;
        operator[8] = 1;
       
      2b11:
        operator[1:0] = 0;
        operator[2] = 1;
       
        operator[3] = 0;
        operator[4] = 1;
        operator[5] = 0;
       
        operator[6] = 1;
        operator[8:7] = 0;
       
      default:
        operator[8:0] = 0;    
    }
    //Output for current_num
    io_led[15:10] = current_num.q;
    output_digit_high = current_num.q/10;
   
    if (game_over.q != 0) {
   
      if (current_num.q < 10 && !game_over.q) {
        output_digit_less = current_num.q;
      } else if (current_num.q >=10 && !game_over.q) {
        output_digit_less = current_num.q - (current_num.q/10)*10;
      }
     
    } else if (game_over.q == 1) {
      //When game over = 1, its a win
      output_digit_less = 0;
      output_digit_high = 0;
      operator[8:0] = 1;
     
    } else if (game_over.q == 2) {
      //When game over = 2, game lost
      output_digit_less = 4;
      output_digit_high = 6;
      operator[8:0] = 0;
     
    }
   
    io_led[18:16] = 0;
   
    if (current_num.q > 63) {
          io_led[9] = 1; //loss
          io_led[8] = 0;
          game_over.d = 2;
          //Write code that resets the game
     } else if (current_num.q <= 0) {
          io_led[8] = 1; //Win
          io_led[9] = 0;
          game_over.d = 1;
          //Write code that resets the game
     }
   
    //RNG functions that are clock dependant
   
    pn_gen.next = 1;
    pn_gen.seed = 0;
   
    pn_gen2.next = 3;
    pn_gen2.seed = 1;
   
    pn_gen3.next = 3;
    pn_gen3.seed = 2;
   
    pn_gen4.next = 2;
    pn_gen4.seed = 3;
   
    pn_gen5.next = 1;
    pn_gen5.seed = 19 + pn_gen6.num;
   
    pn_gen6.next = 1;
    pn_gen6.seed = 21 + pn_gen5.num;
   
  }
}