module game (
    input clk,  // clock
    input rst_n,  // reset
    output rand_number[4],
    output output_digit_less[4],
    output output_digit_high[4],
    output operator[9],
    input switch_i,
    input switch_j,
    input enter,
    input reset
    //output io_led[19]
  ) {
  sig rst;                  // reset signal
  dff number_sequence[4][4](.clk(clk), .rst(rst));
  dff operator_sequence[2][2](.clk(clk), .rst(rst));
  dff game_over[2](.clk(clk),.rst(rst));
 
  dff current_num[12](.clk(clk), .rst(rst));
  dff i[2](.clk(clk), .rst(rst));
  dff j[2](.clk(clk), .rst(rst));
  dff reset_condition(.clk(clk), .rst(rst));
  dff change_i_condition(.clk(clk), .rst(rst));
  dff change_j_condition(.clk(clk), .rst(rst));
  dff enter_condition(.clk(clk), .rst(rst));
  dff v(.clk(clk), .rst(rst));
  
  alu alu;
  alu alu2;
  
  .clk(clk) {
    reset_conditioner reset_cond; 
    //For debouncing
    button_conditioner reset_button; 
    button_conditioner i_button;
    button_conditioner j_button;
    button_conditioner enter_button;
    
    //Detect rising edge
    edge_detector edge_detector_reset(#RISE(1), #FALL(0));
    edge_detector edge_detector_enter(#RISE(1), #FALL(0));
    edge_detector edge_detector_i(#RISE(1), #FALL(0));
    edge_detector edge_detector_j(#RISE(1), #FALL(0));
    
    .rst(rst) {
      pn_gen pn_gen;
      pn_gen pn_gen2;
      pn_gen pn_gen3;
      pn_gen pn_gen4;
      pn_gen pn_gen5;
      pn_gen pn_gen6;
    }
  }

  always {
    output_digit_high = 0;
    output_digit_less = 0;
    
    reset_button.in = reset;
    edge_detector_reset.in = reset_button.out;
    
    i_button.in = switch_i;
    edge_detector_i.in = i_button.out;
    
    j_button.in = switch_j;
    edge_detector_j.in = j_button.out;
    
    enter_button.in = enter;
    edge_detector_enter.in = enter_button.out;
   
    //io_led[18:0] = 0 ;
    alu.a = 0;
    alu.b = 0;
    alu.alufn = 0;
 
    reset_cond.in = ~rst_n; // input raw inverted reset signal
    rst = reset_cond.out;   // conditioned reset
   
    //Check if reset signal has been asserted, basiscally, at this step, the game is reset
    if (edge_detector_reset.out) {
   
   
      //io_led[16] = 1;
      //io_led[18] = 1;
      //Reset game, set current number to random 0-9, assign new numbers and operators to the user
      current_num.d = pn_gen.num[3:0];
      //Only way to restart game
      game_over.d = 0;
     
      reset_condition.d = 1;
     
      //Below are the four inputs that are going to somehow magically generate a number from 0-9
      //We mod these inputs by 10 to make sure they are always from 0-9
      if (pn_gen.num[3:0] < 10) {
        number_sequence.d[0] = pn_gen.num[3:0];
      } else {
        number_sequence.d[0] = pn_gen.num[3:0] - 10;
        //Assigning a non zero value if zero
        if (number_sequence.q[0] <= 0) {
          number_sequence.d[0] = pn_gen.num - 1;
        }
        
      }
     
      if (pn_gen2.num[3:0] < 10) {
        number_sequence.d[1] = pn_gen2.num[3:0];
      } else {
        number_sequence.d[1] = pn_gen2.num[3:0] - 10;
        if (number_sequence.q[1] <= 0) {
          number_sequence.d[1] = pn_gen2.num - 1;
        }
        if (number_sequence.q[1] == number_sequence.q[0]) {
          number_sequence.d[1] = number_sequence.q[0] >> 1;
        }
      }
     
      if (pn_gen3.num[3:0] < 10) {
        number_sequence.d[2] = pn_gen3.num[3:0];
      } else {
        number_sequence.d[2] = pn_gen3.num[3:0] - 10;
        if (number_sequence.q[2] <= 0) {
          number_sequence.d[2] = pn_gen3.num - 1;
        }
        if (number_sequence.q[2] == number_sequence.q[1]) {
          number_sequence.d[2] = number_sequence.q[1] >> 1;
        }
      }
     
      if (pn_gen4.num[3:0] < 10) {
        number_sequence.d[3] = pn_gen4.num[3:0];
      } else {
        number_sequence.d[3] = pn_gen4.num[3:0] - 10;
        if (number_sequence.q[3] <= 0) {
          number_sequence.d[3] = pn_gen4.num - 1;
        }
        if (number_sequence.q[3] == number_sequence.q[2]) {
          number_sequence.d[3] = number_sequence.q[2] >> 1;
        }
      }
     
      //Below two numbers magically select a sign
      //%ing them with 4
      if (pn_gen5.num < 4) {
        operator_sequence.d[0] = pn_gen5.num;
      } else {
        operator_sequence.d[0] = pn_gen5.num - (pn_gen5.num/4)*4;
      }
     
      if (pn_gen6.num < 4) {
        operator_sequence.d[1] = pn_gen6.num;
      } else {
        operator_sequence.d[1] = pn_gen6.num - (pn_gen6.num/4)*4;
        //Making sure not to have two of the same signs
        if (operator_sequence.q[1] == operator_sequence.q[0]) {
          operator_sequence.d[1] = operator_sequence.q[0] + 1;
        }
      }
       
    } else if (!edge_detector_reset.out && reset_condition.q) {
   
      //io_led[16] = 0;
      reset_condition.d = 0;
     
    }
   
    //Check for change in outputed random numbers
    if (edge_detector_i.out) {
   
       //io_led[17] = 1;
   
      if (i.q == 3) {
        i.d = 0;
      } else {
        i.d = i.q + 1;
      }
     
      change_i_condition.d = 1;
     
    } else if (!i_button.out && change_i_condition.q) {
     
      //io_led[17] = 0;
      change_i_condition.d = 0;
     
    }
   
    //Check for change in assigned operators
    if (edge_detector_j.out) {
   
      if (j.q == 1) {
        j.d = 0;
      } else {
        j.d = 1;
      }
     
      change_j_condition.d = 1;
     
    } else if (!j_button.out && change_j_condition.q) {
      change_j_condition.d = 0;
    }
   
    //User has hit enter button, calculate the new current number and check accordingly
    if (edge_detector_enter.out) {
   
      //io_led[18] = 1;
     
      alu.a = current_num.q;
      alu.b = number_sequence.q[i.q];
   
      case(operator_sequence.q[j.q]) {
        2b00: //Performs + operation
          alu.alufn = 6b000000;
        2b01: //Performs - operation
          alu.alufn = 6b000001;
        2b10: //Performs * operation
          alu.alufn = 6b000010;
        2b11: //Performs / operation
          alu.alufn = 6b000011;
        default:
          alu.alufn = 6b000000;
          current_num.d = 0;    
      }
     
      current_num.d = alu.alu_result;
      v.d = alu.v;
     
     
      //Below are the four inputs that are going to somehow magically generate a number from 0-9
      //We mod these inputs by 10 to make sure they are always from 0-9
      if (pn_gen.num[3:0] < 10) {
        number_sequence.d[0] = pn_gen.num[3:0];
      } else {
        number_sequence.d[0] = pn_gen.num[3:0] - 10;
        //Assigning a non zero value if zero
        if (number_sequence.q[0] <= 0) {
          number_sequence.d[0] = pn_gen.num - 1;
        }
        
      }
     
      if (pn_gen2.num[3:0] < 10) {
        number_sequence.d[1] = pn_gen2.num[3:0];
      } else {
        number_sequence.d[1] = pn_gen2.num[3:0] - 10;
        if (number_sequence.q[1] <= 0) {
          number_sequence.d[1] = pn_gen2.num - 1;
        }
        if (number_sequence.q[1] == number_sequence.q[0]) {
          number_sequence.d[1] = number_sequence.q[0] >> 1;
        }
      }
     
      if (pn_gen3.num[3:0] < 10) {
        number_sequence.d[2] = pn_gen3.num[3:0];
      } else {
        number_sequence.d[2] = pn_gen3.num[3:0] - 10;
        if (number_sequence.q[2] <= 0) {
          number_sequence.d[2] = pn_gen3.num - 1;
        }
        if (number_sequence.q[2] == number_sequence.q[1]) {
          number_sequence.d[2] = number_sequence.q[1] >> 1;
        }
      }
     
      if (pn_gen4.num[3:0] < 10) {
        number_sequence.d[3] = pn_gen4.num[3:0];
      } else {
        number_sequence.d[3] = pn_gen4.num[3:0] - 10;
        if (number_sequence.q[3] <= 0) {
          number_sequence.d[3] = pn_gen4.num - 1;
        }
        if (number_sequence.q[3] == number_sequence.q[2]) {
          number_sequence.d[3] = number_sequence.q[2] >> 1;
        }
      }
     
      //Below two numbers magically select a sign
      //%ing them with 4
      if (pn_gen5.num < 4) {
        operator_sequence.d[0] = pn_gen5.num;
      } else {
        operator_sequence.d[0] = pn_gen5.num - (pn_gen5.num/4)*4;
      }
     
      if (pn_gen6.num < 4) {
        operator_sequence.d[1] = pn_gen6.num;
      } else {
        operator_sequence.d[1] = pn_gen6.num - (pn_gen6.num/4)*4;
        //Making sure not to have two of the same signs
        if (operator_sequence.q[1] == operator_sequence.q[0]) {
          operator_sequence.d[1] = operator_sequence.q[0] + 1;
        }
      }
     
      enter_condition.d = 1;
     
    } else if (!enter_button.out && enter_condition.q) {
   
      //io_led[18] = 0;
      enter_condition.d = 0;
     
    }
   
    //Output for number_sequence
    //io_led[3:0] = number_sequence.q[i.q];
    rand_number = number_sequence.q[i.q];
    //output for operator_sequence
    //io_led[7:6] = operator_sequence.q[j.q];
   
    //Manually hard coding some LED sorcery
    case(operator_sequence.q[j.q]) {
      2b00:
        operator[0] = 0;
        operator[1] = 1;
        operator[2] = 0;
       
        operator[5] = 1;
        operator[4] = 1;
        operator[3] = 1;
       
        operator[6] = 0;
        operator[7] = 1;
        operator[8] = 0;
       
      2b01:
        operator[2] = 0;
        operator[1] = 0;
        operator[0] = 0;
       
        operator[5] = 1;
        operator[4] = 1;
        operator[3] = 1;
       
        operator[8] = 0;
        operator[7] = 0;
        operator[6] = 0;
       
      2b10:
        operator[0] = 1;
        operator[1] = 0;
        operator[2] = 1;
       
        operator[3] = 0;
        operator[4] = 1;
        operator[5] = 0;
       
        operator[6] = 1;
        operator[7] = 0;
        operator[8] = 1;
       
      2b11:
        operator[1] = 0;
        operator[0] = 0;
        operator[2] = 1;
       
        operator[3] = 0;
        operator[4] = 1;
        operator[5] = 0;
       
        operator[6] = 1;
        operator[8] = 0;
        operator[7] = 0;
       
      default:
        operator[8:0] = 0;    
    }
    //Output for current_num
    //io_led[15:10] = current_num.q;
    output_digit_high = current_num.q/10;
    
    alu2.a = current_num.q;
    alu2.b = 0;
    alu2.alufn = 6b110111;
   
    
    if (v.q == 1) {
          //io_led[9] = 1; //loss
          //io_led[8] = 0;
          game_over.d = 2;
          //Write code that resets the game
     } 
    
     if (alu2.alu_result[0]) {
          //io_led[8] = 1; //Win
          //io_led[9] = 0;
          game_over.d = 1;
          //Write code that resets the game
     }
   
    if (game_over.q == 0) {
   
      if (current_num.q < 10) {
        output_digit_less = current_num.q;
      } else if (current_num.q >=10) {
        output_digit_less = current_num.q - (current_num.q/10)*10;
      }
     
    } else if (game_over.q == 1) {
      //When game over = 1, its a win
      output_digit_less = 0;
      output_digit_high = 0;
      
      //Set all LEDs to 1
      operator[8] = 1;
      operator[7] = 1;
      operator[6] = 1;
      operator[5] = 1;
      operator[4] = 1;
      operator[3] = 1;
      operator[2] = 1;
      operator[1] = 1;
      operator[0] = 1;
     
    } else if (game_over.q == 2) {
      //When game over = 2, game lost
      output_digit_less = 4;
      output_digit_high = 6;
      
      //Set all LEDs to 0
      operator[8] = 0;
      operator[7] = 0;
      operator[6] = 0;
      operator[5] = 0; 
      operator[4] = 0;
      operator[3] = 0;
      operator[2] = 0;
      operator[1] = 0;
      operator[0] = 0;
     
    }
    
    //RNG functions that are clock dependant
   
    pn_gen.next = 1;
    pn_gen.seed = 0;
   
    pn_gen2.next = 3;
    pn_gen2.seed = 1;
   
    pn_gen3.next = 3;
    pn_gen3.seed = 2;
   
    pn_gen4.next = 2;
    pn_gen4.seed = 21;
   
    pn_gen5.next = 1;
    pn_gen5.seed = 19 + pn_gen6.num;
   
    pn_gen6.next = 1;
    pn_gen6.seed = 21 + pn_gen5.num;
  }
}
