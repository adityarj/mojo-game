module game (
    input clk,  // clock
    input rst_n,  // reset
    output rand_number[4],
    output output_digit_less[4],
    output output_digit_high[4],
    output operator[9],
    input switch_i,
    input switch_j,
    input enter,
    input reset,
    output test_pin
    //output io_led[19]
  ) {
  sig rst;                  // reset signal
  sig rand[9];
  sig temp;
  dff number_sequence[4][4](.clk(clk), .rst(rst));
  dff operator_sequence[2][2](.clk(clk), .rst(rst));
  dff game_over[2](.clk(clk),.rst(rst));
 
  dff current_num[12](.clk(clk), .rst(rst));
  dff i[2](.clk(clk), .rst(rst));
  dff j[2](.clk(clk), .rst(rst));
  dff reset_condition(.clk(clk), .rst(rst));
  dff change_i_condition(.clk(clk), .rst(rst));
  dff change_j_condition(.clk(clk), .rst(rst));
  dff enter_condition(.clk(clk), .rst(rst));
  dff v(.clk(clk), .rst(rst));
  dff n(.clk(clk), .rst(rst));
  
  alu alu;
  alu alu2;
  modulus mod_num1;
  modulus mod_num2;
  modulus mod_num3;
  modulus mod_num4;
  modulus mod_num5;
  modulus mod_num6;
  
  .clk(clk) {
    reset_conditioner reset_cond; 
    //For debouncing
    button_conditioner reset_button; 
    button_conditioner i_button;
    button_conditioner j_button;
    button_conditioner enter_button;
    
    //Detect rising edge
    edge_detector edge_detector_reset(#RISE(1), #FALL(0));
    edge_detector edge_detector_enter(#RISE(1), #FALL(0));
    edge_detector edge_detector_i(#RISE(1), #FALL(0));
    edge_detector edge_detector_j(#RISE(1), #FALL(0));
    
    .rst(rst) {
      pn_gen pn_gen;
      pn_gen pn_gen2;
      pn_gen pn_gen3;
      pn_gen pn_gen4;
      pn_gen pn_gen5;
      pn_gen pn_gen6;
    }
  }

  always {
    rand[0] = 1;
    rand[1] = 2;
    rand[2] = 3;
    rand[3] = 4;
    rand[4] = 5;
    rand[5] = 6;
    rand[6] = 7;
    rand[7] = 8;
    rand[8] = 9;
    
    output_digit_high = 0;
    output_digit_less = 0;
    
    reset_button.in = reset;
    edge_detector_reset.in = reset_button.out;
    
    i_button.in = switch_i;
    edge_detector_i.in = i_button.out;
    
    j_button.in = switch_j;
    edge_detector_j.in = j_button.out;
    
    enter_button.in = enter;
    edge_detector_enter.in = enter_button.out;
   
    alu.a = 0;
    alu.b = 0;
    alu.alufn = 0;
    
    mod_num1.a = 0;
    mod_num1.b = 0;
    
    mod_num2.a = 0;
    mod_num2.b = 0;
    
    mod_num3.a = 0;
    mod_num3.b = 0;
    
    mod_num4.a = 0;
    mod_num4.b = 0;
    
    mod_num5.a = 0; 
    mod_num5.b = 0;
    
    mod_num6.a = 0;
    mod_num6.b = 0;
    
    reset_cond.in = ~rst_n; // input raw inverted reset signal
    rst = reset_cond.out;   // conditioned reset
   
    //Check if reset signal has been asserted, basiscally, at this step, the game is reset
    if (edge_detector_reset.out) {
   
      //Reset game, set current number to random 0-9, assign new numbers and operators to the user
      current_num.d = pn_gen.num[3:0];
      if (current_num.q == 0) {
        current_num.d = 1 + (pn_gen2.num - pn_gen3.num);
      }
      //Only way to restart game
      game_over.d = 0;
      v.d = 0;
      reset_condition.d = 1;
     
      //Below are the four inputs that are going to somehow magically generate a number from 0-9
      //We mod these inputs by 10 to make sure they are always from 0-9
      mod_num1.a = pn_gen.num;
      mod_num1.b = 9;
      number_sequence.d[0] = rand[mod_num1.out];
      
      temp = rand[8];
      rand[8] = rand[mod_num1.out];
      rand[mod_num1.out] = temp;
      
      mod_num2.a = pn_gen2.num;
      mod_num2.b = 8;
      number_sequence.d[1] = rand[mod_num2.out];
     
      mod_num3.a = pn_gen3.num;
      mod_num3.b = 7;
      number_sequence.d[2] = mod_num3.out;
     
      mod_num4.a = pn_gen4.num;
      mod_num4.b = 6;
      number_sequence.d[3] = mod_num4.out;
     
      //Below two numbers magically select a sign
      //%ing them with 4
      mod_num5.a = pn_gen5.num;
      mod_num5.b = 4;
      operator_sequence.d[0] = mod_num5.out;
      
      mod_num6.a = pn_gen6.num;
      mod_num6.b = 4;
      operator_sequence.d[1] = mod_num6.out;
    } 
   
    //Check for change in outputed random numbers
    if (edge_detector_i.out) {
   
      if (i.q == 3) {
        i.d = 0;
      } else {
        i.d = i.q + 1;
      }
    } 
   
    //Check for change in assigned operators
    if (edge_detector_j.out) {
   
      if (j.q == 1) {
        j.d = 0;
      } else {
        j.d = 1;
      }
    } 
   
    //User has hit enter button, calculate the new current number and check accordingly
    if (edge_detector_enter.out) {
     
      alu.a = current_num.q;
      alu.b = number_sequence.q[i.q];
      
      case(operator_sequence.q[j.q]) {
        2b00: //Performs + operation
          alu.alufn = 6b000000;
        2b01: //Performs - operation
          alu.alufn = 6b000001;
        2b10: //Performs * operation
          alu.alufn = 6b000010;
        2b11: //Performs / operation
          alu.alufn = 6b000011;
        default:
          alu.alufn = 6b000000;
          current_num.d = 0;    
      }
     
      current_num.d = alu.alu_result;
      v.d = alu.v;
      n.d = alu.n;
     
       //Below are the four inputs that are going to somehow magically generate a number from 0-9
      //We mod these inputs by 10 to make sure they are always from 0-9
      mod_num1.a = pn_gen.num;
      mod_num1.b = 10;
      number_sequence.d[0] = mod_num1.out;
      
      mod_num2.a = pn_gen2.num;
      mod_num2.b = 10;
      number_sequence.d[1] = mod_num2.out;
     
      mod_num3.a = pn_gen3.num;
      mod_num3.b = 10;
      number_sequence.d[2] = mod_num3.out;
     
      mod_num4.a = pn_gen4.num;
      mod_num4.b = 10;
      number_sequence.d[3] = mod_num4.out;
     
      //Below two numbers magically select a sign
      //%ing them with 4
      mod_num5.a = pn_gen5.num;
      mod_num5.b = 4;
      operator_sequence.d[0] = mod_num5.out;
      
      mod_num6.a = pn_gen6.num;
      mod_num6.b = 4;
      operator_sequence.d[1] = mod_num6.out;
     
      enter_condition.d = 1;
     
    } 
     
    rand_number = number_sequence.q[i.q];  
   
    //Manually hard coding some LED sorcery
    case(operator_sequence.q[j.q]) {
      2b00:
        operator = 9b010111010;
       
      2b01:
        operator = 9b000111000;
       
      2b10:
        operator = 9b101010101;
       
      2b11:
        operator = 9b001010100;

      default:
        operator[8:0] = 0;    
    }
    //Output for current_num
    output_digit_high = current_num.q/10;
    
    alu2.a = current_num.q;
    alu2.b = 0;
    alu2.alufn = 6b110111;
   
    test_pin = 0;
    
    if (v.q == 1) {
          game_over.d = 2;
     } 
    
     else if (alu2.alu_result[0] | n.q == 1) {
          game_over.d = 1;
     }
   
    if (game_over.q == 0) {
          
      if (current_num.q < 10) {
        output_digit_less = current_num.q;
      } else if (current_num.q >=10) {
        output_digit_less = current_num.q - (current_num.q/10)*10;
      }
     
    } else if (game_over.q == 1) {
    
      //When game over = 1, its a win
      output_digit_less = 0;
      output_digit_high = 0;
      
      //Set all LEDs to 1
      operator = 9b111111111;
     
    } else if (game_over.q == 2) {
      //When game over = 2, game lost
      output_digit_less = 4;
      output_digit_high = 6;
      
      //Set all LEDs to 0
      operator = 9b000000000;
     
    }
    
    //RNG functions that are clock dependant
   
    pn_gen.next = 1;
    pn_gen.seed = 0;
   
    pn_gen2.next = 3;
    pn_gen2.seed = 1;
   
    pn_gen3.next = 3;
    pn_gen3.seed = 2;
   
    pn_gen4.next = 2;
    pn_gen4.seed = 21;
   
    pn_gen5.next = 1;
    pn_gen5.seed = 19 + pn_gen6.num;
   
    pn_gen6.next = 1;
    pn_gen6.seed = 21 + pn_gen5.num;
  }
}